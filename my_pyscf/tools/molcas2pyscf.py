import h5py
import numpy as np
from pyscf.symm.param import IRREP_ID_MOLPRO as IRREP_ID_MOLCAS

def get_mo_from_h5 (mol, h5fname):
    ''' Get MO vectors for a pyscf molecule from an h5 file written by OpenMolcas

        Args:
            mol : instance gto.mole
                Must be in the same point group as the OpenMolcas calculation
            h5fname : str
                Path to an h5 file generated by OpenMolcas containing (at least) groups
                'BASIS_FUNCTION_IDS', 'DESYM_MATRIX', 'MO_VECTORS', and 'MO_ENERGIES'

        Returns:
            mo_coeff : ndarray of shape (nao_nr, nao_nr)
    '''

    idx_irrep = np.argsort (IRREP_ID_MOLCAS[mol.groupname])
    nmo_irrep = [mol.symm_orb[ir].shape[1] for ir in idx_irrep]

    with h5py.File (h5fname, 'r') as f:
        molcas_basids = np.asarray (f['DESYM_BASIS_FUNCTION_IDS'])
        molcas_usymm = np.asarray (f['DESYM_MATRIX'])
        molcas_coeff = np.asarray (f['MO_VECTORS'])
        mo_energy = np.asarray (f['MO_ENERGIES'])

    uuu = [m_ir * mol.nao_nr () for m_ir in nmo_irrep]
    usymm_irrep_offset = [0] + [sum (uuu[:i+1]) for i in range (len (uuu)-1)]
    uuu = [m_ir * m_ir for m_ir in nmo_irrep]
    coeff_irrep_offset = [0] + [sum (uuu[:i+1]) for i in range (len (uuu)-1)]
    orb_irrep_offset = [0] + [sum (nmo_irrep[:i+1]) for i in range (len (nmo_irrep)-1)]
    mo_coeff = np.zeros ((mol.nao_nr (), mol.nao_nr ()), dtype=np.float_)
    for m_ir, orb_off, usymm_off, coeff_off in zip (nmo_irrep, orb_irrep_offset, usymm_irrep_offset, coeff_irrep_offset):
        usymm = molcas_usymm[usymm_off:usymm_off+(m_ir*mol.nao_nr ())].reshape (m_ir, mol.nao_nr ()).T
        coeff = molcas_coeff[coeff_off:coeff_off+(m_ir*m_ir)].reshape (m_ir, m_ir).T
        mo_coeff[:,orb_off:orb_off+m_ir] = np.dot (usymm, coeff)

    idx_ao = []
    for (c, n, l, m) in molcas_basids:
        # 0-index atom list in PySCF, 1-index atom list in Molcas
        c -= 1
        # Actual principal quantum number in PySCF, 1-indexed list in Molcas
        n += l
        # l=1, ml=(-1,0,1) is (x,y,z) in PySCF, (y,z,x) in Molcas
        if l == 1:
            m = m - 2 if m > 0 else m + 1
        idx_ao.append (mol.search_ao_nr (c, l, m, n))
    idx_ao = np.argsort (np.asarray (idx_ao))
    mo_coeff = mo_coeff[idx_ao,:]

    # 'mergesort' keeps degenerate or active-space orbitals in the provided order!
    idx_ene = np.argsort (mo_energy, kind='mergesort')
    mo_coeff = mo_coeff[:,idx_ene]

    return mo_coeff

